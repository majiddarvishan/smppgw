#include "bit_set.h"

#include <cassert>
#include <cmath>
#include <cstring>
#include <iostream>

const std::array<uint64_t, 64> bit_set::ind_set_ = {
    0b0000000000000000000000000000000000000000000000000000000000000001ull, 0b0000000000000000000000000000000000000000000000000000000000000010ull,
    0b0000000000000000000000000000000000000000000000000000000000000100ull, 0b0000000000000000000000000000000000000000000000000000000000001000ull,
    0b0000000000000000000000000000000000000000000000000000000000010000ull, 0b0000000000000000000000000000000000000000000000000000000000100000ull,
    0b0000000000000000000000000000000000000000000000000000000001000000ull, 0b0000000000000000000000000000000000000000000000000000000010000000ull,
    0b0000000000000000000000000000000000000000000000000000000100000000ull, 0b0000000000000000000000000000000000000000000000000000001000000000ull,
    0b0000000000000000000000000000000000000000000000000000010000000000ull, 0b0000000000000000000000000000000000000000000000000000100000000000ull,
    0b0000000000000000000000000000000000000000000000000001000000000000ull, 0b0000000000000000000000000000000000000000000000000010000000000000ull,
    0b0000000000000000000000000000000000000000000000000100000000000000ull, 0b0000000000000000000000000000000000000000000000001000000000000000ull,
    0b0000000000000000000000000000000000000000000000010000000000000000ull, 0b0000000000000000000000000000000000000000000000100000000000000000ull,
    0b0000000000000000000000000000000000000000000001000000000000000000ull, 0b0000000000000000000000000000000000000000000010000000000000000000ull,
    0b0000000000000000000000000000000000000000000100000000000000000000ull, 0b0000000000000000000000000000000000000000001000000000000000000000ull,
    0b0000000000000000000000000000000000000000010000000000000000000000ull, 0b0000000000000000000000000000000000000000100000000000000000000000ull,
    0b0000000000000000000000000000000000000001000000000000000000000000ull, 0b0000000000000000000000000000000000000010000000000000000000000000ull,
    0b0000000000000000000000000000000000000100000000000000000000000000ull, 0b0000000000000000000000000000000000001000000000000000000000000000ull,
    0b0000000000000000000000000000000000010000000000000000000000000000ull, 0b0000000000000000000000000000000000100000000000000000000000000000ull,
    0b0000000000000000000000000000000001000000000000000000000000000000ull, 0b0000000000000000000000000000000010000000000000000000000000000000ull,
    0b0000000000000000000000000000000100000000000000000000000000000000ull, 0b0000000000000000000000000000001000000000000000000000000000000000ull,
    0b0000000000000000000000000000010000000000000000000000000000000000ull, 0b0000000000000000000000000000100000000000000000000000000000000000ull,
    0b0000000000000000000000000001000000000000000000000000000000000000ull, 0b0000000000000000000000000010000000000000000000000000000000000000ull,
    0b0000000000000000000000000100000000000000000000000000000000000000ull, 0b0000000000000000000000001000000000000000000000000000000000000000ull,
    0b0000000000000000000000010000000000000000000000000000000000000000ull, 0b0000000000000000000000100000000000000000000000000000000000000000ull,
    0b0000000000000000000001000000000000000000000000000000000000000000ull, 0b0000000000000000000010000000000000000000000000000000000000000000ull,
    0b0000000000000000000100000000000000000000000000000000000000000000ull, 0b0000000000000000001000000000000000000000000000000000000000000000ull,
    0b0000000000000000010000000000000000000000000000000000000000000000ull, 0b0000000000000000100000000000000000000000000000000000000000000000ull,
    0b0000000000000001000000000000000000000000000000000000000000000000ull, 0b0000000000000010000000000000000000000000000000000000000000000000ull,
    0b0000000000000100000000000000000000000000000000000000000000000000ull, 0b0000000000001000000000000000000000000000000000000000000000000000ull,
    0b0000000000010000000000000000000000000000000000000000000000000000ull, 0b0000000000100000000000000000000000000000000000000000000000000000ull,
    0b0000000001000000000000000000000000000000000000000000000000000000ull, 0b0000000010000000000000000000000000000000000000000000000000000000ull,
    0b0000000100000000000000000000000000000000000000000000000000000000ull, 0b0000001000000000000000000000000000000000000000000000000000000000ull,
    0b0000010000000000000000000000000000000000000000000000000000000000ull, 0b0000100000000000000000000000000000000000000000000000000000000000ull,
    0b0001000000000000000000000000000000000000000000000000000000000000ull, 0b0010000000000000000000000000000000000000000000000000000000000000ull,
    0b0100000000000000000000000000000000000000000000000000000000000000ull, 0b1000000000000000000000000000000000000000000000000000000000000000ull,
};

const std::array<uint64_t, 64> bit_set::ind_unset_ = {
    0b1111111111111111111111111111111111111111111111111111111111111110ull, 0b1111111111111111111111111111111111111111111111111111111111111101ull,
    0b1111111111111111111111111111111111111111111111111111111111111011ull, 0b1111111111111111111111111111111111111111111111111111111111110111ull,
    0b1111111111111111111111111111111111111111111111111111111111101111ull, 0b1111111111111111111111111111111111111111111111111111111111011111ull,
    0b1111111111111111111111111111111111111111111111111111111110111111ull, 0b1111111111111111111111111111111111111111111111111111111101111111ull,
    0b1111111111111111111111111111111111111111111111111111111011111111ull, 0b1111111111111111111111111111111111111111111111111111110111111111ull,
    0b1111111111111111111111111111111111111111111111111111101111111111ull, 0b1111111111111111111111111111111111111111111111111111011111111111ull,
    0b1111111111111111111111111111111111111111111111111110111111111111ull, 0b1111111111111111111111111111111111111111111111111101111111111111ull,
    0b1111111111111111111111111111111111111111111111111011111111111111ull, 0b1111111111111111111111111111111111111111111111110111111111111111ull,
    0b1111111111111111111111111111111111111111111111101111111111111111ull, 0b1111111111111111111111111111111111111111111111011111111111111111ull,
    0b1111111111111111111111111111111111111111111110111111111111111111ull, 0b1111111111111111111111111111111111111111111101111111111111111111ull,
    0b1111111111111111111111111111111111111111111011111111111111111111ull, 0b1111111111111111111111111111111111111111110111111111111111111111ull,
    0b1111111111111111111111111111111111111111101111111111111111111111ull, 0b1111111111111111111111111111111111111111011111111111111111111111ull,
    0b1111111111111111111111111111111111111110111111111111111111111111ull, 0b1111111111111111111111111111111111111101111111111111111111111111ull,
    0b1111111111111111111111111111111111111011111111111111111111111111ull, 0b1111111111111111111111111111111111110111111111111111111111111111ull,
    0b1111111111111111111111111111111111101111111111111111111111111111ull, 0b1111111111111111111111111111111111011111111111111111111111111111ull,
    0b1111111111111111111111111111111110111111111111111111111111111111ull, 0b1111111111111111111111111111111101111111111111111111111111111111ull,
    0b1111111111111111111111111111111011111111111111111111111111111111ull, 0b1111111111111111111111111111110111111111111111111111111111111111ull,
    0b1111111111111111111111111111101111111111111111111111111111111111ull, 0b1111111111111111111111111111011111111111111111111111111111111111ull,
    0b1111111111111111111111111110111111111111111111111111111111111111ull, 0b1111111111111111111111111101111111111111111111111111111111111111ull,
    0b1111111111111111111111111011111111111111111111111111111111111111ull, 0b1111111111111111111111110111111111111111111111111111111111111111ull,
    0b1111111111111111111111101111111111111111111111111111111111111111ull, 0b1111111111111111111111011111111111111111111111111111111111111111ull,
    0b1111111111111111111110111111111111111111111111111111111111111111ull, 0b1111111111111111111101111111111111111111111111111111111111111111ull,
    0b1111111111111111111011111111111111111111111111111111111111111111ull, 0b1111111111111111110111111111111111111111111111111111111111111111ull,
    0b1111111111111111101111111111111111111111111111111111111111111111ull, 0b1111111111111111011111111111111111111111111111111111111111111111ull,
    0b1111111111111110111111111111111111111111111111111111111111111111ull, 0b1111111111111101111111111111111111111111111111111111111111111111ull,
    0b1111111111111011111111111111111111111111111111111111111111111111ull, 0b1111111111110111111111111111111111111111111111111111111111111111ull,
    0b1111111111101111111111111111111111111111111111111111111111111111ull, 0b1111111111011111111111111111111111111111111111111111111111111111ull,
    0b1111111110111111111111111111111111111111111111111111111111111111ull, 0b1111111101111111111111111111111111111111111111111111111111111111ull,
    0b1111111011111111111111111111111111111111111111111111111111111111ull, 0b1111110111111111111111111111111111111111111111111111111111111111ull,
    0b1111101111111111111111111111111111111111111111111111111111111111ull, 0b1111011111111111111111111111111111111111111111111111111111111111ull,
    0b1110111111111111111111111111111111111111111111111111111111111111ull, 0b1101111111111111111111111111111111111111111111111111111111111111ull,
    0b1011111111111111111111111111111111111111111111111111111111111111ull, 0b0111111111111111111111111111111111111111111111111111111111111111ull,
};

bit_set::~bit_set()
{
    delete[] storage_;
    storage_ = nullptr;
}

bit_set::bit_set(size_t t_size)
    : word_size_(static_cast<size_t>(std::ceil(static_cast<double>(t_size) / 64)))
    , size_(t_size)
{
    storage_ = new uint64_t[word_size_]{ 0 }; //new initialized it to zero
}

bit_set::bit_set(const bit_set& otherbit_set)
    : word_size_(otherbit_set.word_size_)
    , size_(otherbit_set.size_)
{
    storage_ = new uint64_t[word_size_]{ 0 };
    std::memcpy(storage_, otherbit_set.storage_, word_size_ * 64);
}

bit_set::bit_set(bit_set&& otherbit_set) noexcept
    : word_size_(otherbit_set.word_size_)
    , size_(otherbit_set.size_)
{
    storage_ = otherbit_set.storage_;
    otherbit_set.storage_ = nullptr;
}

void bit_set::operator&=(const bit_set& rhs)
{
    assert(word_size_ == rhs.word_size_);

    for(size_t i = 0; i < word_size_; i++)
    {
        storage_[i] &= rhs.storage_[i];
    }
}

void bit_set::operator|=(const bit_set& rhs)
{
    assert(word_size_ == rhs.word_size_);

    for(size_t i = 0; i < word_size_; i++)
    {
        storage_[i] |= rhs.storage_[i];
    }
}

bool bit_set::operator==(const bit_set& rhs) const
{
    assert(word_size_ == rhs.word_size_);

    for(size_t i = 0; i < word_size_; i++)
    {
        if(storage_[i] != rhs.storage_[i])
        {
            return false;
        }
    }

    return true;
}

bool bit_set::check_set_flags(const bit_set& cond) const
{
    assert(word_size_ == cond.word_size_);

    for(size_t i = 0; i < word_size_; i++)
    {
        if((storage_[i] & cond.storage_[i]) != cond.storage_[i])
        {
            return false;
        }
    }

    return true;
}

bool bit_set::check_unset_flags(const bit_set& cond) const
{
    assert(word_size_ == cond.word_size_);

    for(size_t i = 0; i < word_size_; i++)
    {
        if((~storage_[i] & cond.storage_[i]) != cond.storage_[i])
        {
            return false;
        }
    }

    return true;
}

void bit_set::shift_right()
{
    for(size_t i = word_size_ - 1; i > 0; i--)
    {
        storage_[i] <<= 1;

        if(storage_[i - 1] & 0x8000000000000000ull)
        {
            storage_[i] |= 0x0000000000000001ull;
        }
    }

    storage_[0] <<= 1;
}

void bit_set::set(const size_t ind, bool value)
{
    assert(ind < size_);
    auto div_res = std::div(ind, 64);

    if(value)
    {
        storage_[div_res.quot] |= ind_set_[div_res.rem];
    }
    else
    {
        storage_[div_res.quot] &= ind_unset_[div_res.rem];
    }
}

bool bit_set::get(size_t ind) const
{
    assert(ind < size_);
    auto div_res = std::div(ind, 64);
    return ((storage_[div_res.quot] & ind_set_[div_res.rem])) ? true : false;
}

std::string bit_set::to_string() const
{
    std::string ret(size_, '0');
    std::div_t res;

    for(size_t i = 0; i < size_; i++)
    {
        res = std::div(i, 64);

        if((storage_[res.quot] & ind_set_[res.rem]))
        {
            ret[i] = '1';
        }
    }

    return ret;
}

std::vector<size_t> bit_set::get_set_bits_indices() const
{
    std::vector<size_t> ret;
    ret.reserve(64);
#ifdef __GNUG__
    uint64_t tmp;
    size_t pos;

    for(size_t i = 0; i < word_size_; i++)
    {
        tmp = storage_[i];

        while(tmp)
        {
            pos = static_cast<size_t>(__builtin_ctzll(tmp));
            ret.push_back((i * 64) + pos);
            tmp ^= (1ull << pos);
        }
    }

#else //ifdef __GNUG__
    std::div_t res;

    for(size_t i = 0; i < size_; i++)
    {
        res = std::div(i, 64);

        if((storage_[res.quot] & ind_set_[res.rem]))
        {
            ret.push_back(i);
        }
    }

#endif //ifdef __GNUG__
    return ret;
} //bit_set::get_set_bits_indices
